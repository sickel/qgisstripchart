# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StripChart
                                 A QGIS plugin
 Draws a strip chart for a feature from a layer. This is primarily intended for 
 timeseries, but may be used and make sense for any sortable data.
 Presently the dataset is being sorted by the field "id". The only way to sort 
 on another field is to change the value idfield. In a future version, this 
 value will be user selectable.
 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-10-13
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Morten Sickel
        email                : morten@sickel.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .stripchart_dockwidget import StripChartDockWidget
import os.path

from qgis.PyQt.QtGui import QPen
from qgis.core import QgsProject, Qgis, QgsFeatureRequest
from qgis.PyQt.QtWidgets import QGraphicsScene,QApplication,QGraphicsView


class StripChart:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'StripChart_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Stripchart')
        self.toolbar = self.iface.addToolBar(u'Stripchart')
        self.toolbar.setObjectName(u'Stripchart')

        #print "** INITIALIZING StripChart"
        self.view = MouseReadGraphicsView(self.iface)
        self.view.layer=None
        self.pluginIsActive = False
        # self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Stripchart', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToDatabaseMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/stripchart/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Stripchart'),
            callback=self.run,
            parent=self.iface.mainWindow())
        self.dlg=StripChartDockWidget(self.iface.mainWindow())
        self.view.setParent(self.dlg) 
        self.dlg.vlMain.addWidget(self.view)
        self.scene=QGraphicsScene()
        self.view.setScene(self.scene)
        self.scene.setSceneRect(0,0,300,2000)
            


    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""
        # disconnects
        self.dlg.closingPlugin.disconnect(self.onClosePlugin)
        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginDatabaseMenu(
                self.tr(u'Stripchart'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------


    def listfields(self):
        """ When selecting a new layer. List fields for that layer"""
        # TODO: Check if the existing fieldname still is in the list, if so, select that
        self.dlg.cbItem.clear()
        layername=self.dlg.cbLayer.currentText()
        layers = QgsProject.instance().mapLayersByName(layername) # list of layers with any name
        if len(layers)==0:
            return
        self.view.layer = layers[0] # first layer with actual name. Need to somehow handle if several layers with same name.
        fields = self.view.layer.fields().names() #Get Fields
        # TODO: Should only add relevant (i.e. numeric) fields
        self.dlg.cbItem.addItems(fields) #Added to the comboBox
    

    def stripchart(self):
        """ Finds the data to draw, scales the chart and draws the data"""
        layername=self.dlg.cbLayer.currentText()
        layers = QgsProject.instance().mapLayersByName(layername) # list of layers with selected name
        if len(layers)==0:
            return # IT has somehow been called with an invalid layer name
        self.view.layer = layers[0] # first layer with the actual name
        self.view.ids=[] # Keeps the ids .
        fieldname=self.dlg.cbItem.currentText()
        if fieldname=='' or fieldname is None:
            return # Called with invalid field name
        self.view.values=[]
        request = QgsFeatureRequest().addOrderBy('Id').setFlags(QgsFeatureRequest.NoGeometry). setSubsetOfAttributes([self.view.idfield,fieldname], self.view.layer.fields() )
        iter=self.view.layer.getFeatures(request)
        for feature in iter:
            if isinstance(feature[fieldname],list):
                # This is not optimal. Should check type before entering loop 
                # Should only accept numeric features
                # TODO: Check before entering loop
                # TODO: Only allow numerical types
                 self.iface.messageBar().pushMessage(
                    "Error", "Invalid field type : {}".format(fieldname),
                    level=Qgis.Warning, duration=3) # Info, Warning, Critical, Success
                 return # Invalid field type
            self.view.values.append(feature[fieldname]) 
            # TODO: Mouse action to read out values from stripchart
            # USing values[] to find min and max values and to find the number of features
            self.view.ids.append(feature[self.view.idfield])  
        self.scene.setSceneRect(0,0,self.view.width,len(self.view.values))
        self.scene.clear()
        maxval=max(self.view.values)
        minval=min(self.view.values)
        # TODO: Make a sensible scaling using min and maxval
        scale=self.view.width/maxval
        n=0
        for v in self.view.values:
            self.scene.addLine(0,n,v*scale,n)
            n+=1
        
    def setuplayers(self):
        """ Listing of layers """
        # TODO: Filter so only vector layers are listed
        layers = QgsProject.instance().layerTreeRoot().children()
        self.dlg.cbLayer.clear()
        for layer in layers:
            # if layer.layer()type==QgsMapLayer.Vectorlayer: ## returns nothing...?
                self.dlg.cbLayer.addItems([layer.name()])
        self.listfields()
        

    def run(self):
        """Run method that loads and starts the plugin"""
        self.init=True
        if not self.pluginIsActive:
            self.pluginIsActive = True
            # connect to provide cleanup on closing of dockwidget
            self.dlg.closingPlugin.connect(self.onClosePlugin)
            self.iface.mainWindow().addDockWidget(Qt.RightDockWidgetArea, self.dlg)
            # Move to initGui() - did not seem to work
            self.dlg.cbLayer.currentIndexChanged['QString'].connect(self.listfields)
            self.dlg.cbItem.currentIndexChanged['QString'].connect(self.stripchart)
            self.iface.mapCanvas().selectionChanged.connect(self.markselected)
            self.setuplayers() # Loading layers. If moved to initGui() it will run before project is loaded.
            # Per now: Needs to close and reopen plugin to update layer list
            # TODO: FInd way to update dynamically. Important: Do not redraw stripchart accidentially
            self.dlg.show()
            
    def markselected(self):
        """ Run when the selection is changed. Kicks of the redrawing to a method in the graphics view"""
        if self.view.layer==None:
            return
        sels=self.view.layer.selectedFeatures() # The selected features in the active (from this plugin's point of view) layer
        n=len(sels)
        self.view.clearselection()
        if n>0:
            self.view.markselection(sels)

class MouseReadGraphicsView(QGraphicsView):
    def __init__(self, iface):
        """ Sets up the customised graphicsview"""
        self.iface = iface
        QGraphicsView.__init__(self)
        self.selectlines=[] # Must keep lines drawn to be able to delete them
        self.ids=[]         # Usesd to map from y-coordinates to ids in the dataset
        self.width=250
        self.idfield='id'   # Needs to be userselectable or autoset
        # TODO: set default to "id", if no id, set to "fid". If neither, refuse to plot from layer
        
    def selectmarker(self,y):
        """ Drawing a yellow line behind the stripchart to mark a selected items"""
        selectpen=QPen(Qt.yellow)
        # TODO: Set to same color as selection color in the data set or set userselectable
        markline=self.scene().addLine(0,y,250,y,selectpen) 
        markline.setZValue(-1)             # Puts it behind the stripchart
        self.selectlines.append(markline)  # Stores it so that it can be deleted later on
    
    def clearselection(self):
        """ Delete all lines in strip chart showing selections """
        for line in self.selectlines:
             self.scene().removeItem(line)
        
    def markselection(self,sels):
        """ Goes through selected items to mark them in the stripchart """
        for sel in sels:
            idval=sel[self.idfield]
            y=self.ids.index(idval)
            self.selectmarker(y)
        
    #TODO - handle ctrl and/or shift click and drags correctly
    def mousePressEvent(self, event):
        """ Catches y-coordinate where mousebutton is pressed"""
        if event.button() == 1:
            coords=self.mapToScene(event.pos())    
            self.ypress=coords.y() # Storing where the button was clicked
                    
                    
    def mouseReleaseEvent(self, event):
        """ Catches y coordinate where mousebutton is released, selects data for area mousebutton was pressed"""
        # Something strange happens, but it is no big problem:
        # If mousebutton is pressed and released within stripchart - works fine
        # If mousebutton is pressed outside stripchart and released within stripchart - nothing happens 
        # If nousebutton is pressed within stripchart and released outside stripchart - y coordinate from release is registered 
        # if it is within the scene coordinates
        if event.button() == 1:
            coords=self.mapToScene(event.pos())  
            yrelease=coords.y()
            if yrelease==None:
                yrelease=0
            if self.ypress==None:
                self.ypress=0
            if self.layer== None:
                return
            # Should work for drags in both directions:
            ymin=int(min(yrelease,self.ypress))
            ymax=int(max(yrelease,self.ypress))
            if ymin==ymax:
                ymax+=1
            selectedids=self.ids[ymin:ymax]
            # Selects the items in the data set
            # This causes a call to markselection()
            self.layer.select(selectedids)
            self.ypress=None
